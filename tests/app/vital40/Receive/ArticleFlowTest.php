<?php
/**
 * Created by PhpStorm.
 * User: pneal
 * Date: 27/04/15
 * Time: 5:25 PM
 */

namespace tests\App\vital40\Receive;

use App\vital40\Receive\ArticleFlow;

class ConfigMock {
    public static $expectedKeys = [
        'ReceivePO' => 'constants.userActivity.classID.ReceivePO',
        'ReceiveLocation' => 'constants.userActivity.classID.ReceiveLocation',
        'ReceiveArticle' => 'constants.userActivity.classID.ReceiveArticle',
        'statusReceived' => 'constants.inventory.status.received'
    ];
    public static $key;
    public static $count = 0;
    public static function get($key) {
        self::$key=$key;
        self::$count++;
        return $key;
    }
}
class_alias('tests\App\vital40\Receive\ConfigMock', 'Config');

class LangMock {
    public static $expectedKeys = [
        'ReceivePO' => 'internal.userActivity.purpose.receivePO',
        'ReceiveLocation' => 'internal.userActivity.purpose.receiveLocation',
        'ReceiveArticle' => 'internal.userActivity.purpose.receiveArticle',
    ];
    public static $key;
    public static $count = 0;
    public static function get($key, $arr=array(), $arr2=array()) {
        self::$key=$key;
        self::$count++;
        return $key;
    }
}
class_alias('tests\App\vital40\Receive\LangMock', 'Lang');

class LogMock {
    public static $debugMsg = '';
    public static $debugCnt = 0;
    public static function debug($message) {
        self::$debugMsg.=$message;
        self::$debugCnt++;
    }
}
class_alias('tests\App\vital40\Receive\LogMock', 'Log');

class ArticleFlowTest extends \PHPUnit_Framework_TestCase {

    protected static $articleRepository;
    protected static $palletRepository;
    protected static $purchaseOrderRepository;
    protected static $purchaseOrderDetailRepository;
    protected static $receiptHistoryRepository;
    protected static $toteRepository;
    protected static $upcRepository;
    protected static $userActivityRepository;
    protected static $locationRepository;
    protected static $inventoryRepository;

    protected static $Purchase_Order = 'PO-123';
    protected static $Location_objectID = "00070004";
    protected static $Location_Name = 'Workbench-4';
    protected static $PurchaseOrderDetail_objectID = 'pod-567';
    protected static $UPC = 'upc-890';

    protected $articleFlow;
    protected $purchaseOrder;
    protected $location;
    protected $purchaseOrderDetail;
    protected $article;

    public static function setUpBeforeClass()
    {
        parent::setUpBeforeClass(); // TODO: Change the autogenerated stub
        fwrite(STDOUT, __METHOD__ . "(" . __LINE__ . ")\n");

        self::$articleRepository = NULL;
        self::$palletRepository = NULL;
        self::$purchaseOrderRepository = NULL;
        self::$purchaseOrderDetailRepository = NULL;
        self::$receiptHistoryRepository = NULL;
        self::$toteRepository = NULL;
        self::$upcRepository = NULL;
        self::$userActivityRepository = NULL;
        self::$locationRepository = NULL;
        self::$inventoryRepository = NULL;
    }

    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        if(!isset(self::$articleRepository)) {
            fwrite(STDOUT, __METHOD__."(".__LINE__."): setUp Repository Interfaces\n");
            self::$articleRepository = $this->getMockBuilder('vital40\Repositories\ArticleRepositoryInterface')->getMock();
            self::$palletRepository = $this->getMockBuilder('vital3\Repositories\PalletRepositoryInterface')->getMock();
            self::$purchaseOrderRepository = $this->getMockBuilder('vital40\Repositories\PurchaseOrderRepositoryInterface')->getMock();
            self::$purchaseOrderDetailRepository = $this->getMockBuilder('vital40\Repositories\PurchaseOrderDetailRepositoryInterface')->getMock();
            self::$receiptHistoryRepository = $this->getMockBuilder('vital40\Repositories\ReceiptHistoryRepositoryInterface')->getMock();
            self::$toteRepository = $this->getMockBuilder('vital40\Repositories\ToteRepositoryInterface')->getMock();
            self::$upcRepository = $this->getMockBuilder('vital40\Repositories\UPCRepositoryInterface')->getMock();
            //self::$userActivityRepository = $this->getMockBuilder('vital40\Repositories\UserActivityRepositoryInterface')->getMock();
            self::$locationRepository = $this->getMockBuilder('vital3\Repositories\LocationRepositoryInterface')->getMock();
            self::$inventoryRepository = $this->getMockBuilder('vital3\Repositories\InventoryRepositoryInterface')->getMock();
        }
        self::$userActivityRepository = $this->getMockBuilder('vital40\Repositories\UserActivityRepositoryInterface')->getMock();

        $this->articleFlow = new ArticleFlow(
            self::$articleRepository, self::$palletRepository, self::$purchaseOrderRepository
            , self::$purchaseOrderDetailRepository, self::$receiptHistoryRepository, self::$toteRepository
            , self::$upcRepository, self::$userActivityRepository, self::$locationRepository, self::$inventoryRepository
        );

        $this->purchaseOrder = (object)['Purchase_Order' => self::$Purchase_Order];
        $this->location = (object)['objectID' => self::$Location_objectID, 'Location_Name' => self::$Location_Name];
        $this->purchaseOrderDetail = (object)['objectID' => self::$PurchaseOrderDetail_objectID];
        $this->article = (object)['UPC' => self::$UPC];

        ConfigMock::$key = "";
        ConfigMock::$count = 0;
        LangMock::$key = "";
        LangMock::$count = 0;
    }

    protected function assertPreConditions()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        $this->assertAttributeEquals(self::$Purchase_Order, 'Purchase_Order', $this->purchaseOrder);
        $this->assertEquals(self::$Purchase_Order, $this->purchaseOrder->Purchase_Order);
    }

    protected function tearDown()
    {
        parent::tearDown(); // TODO: Change the autogenerated stub
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
    }

    public static function tearDownAfterClass()
    {
        parent::tearDownAfterClass(); // TODO: Change the autogenerated stub
        fwrite(STDOUT, __METHOD__ . "(" . __LINE__ . ")\n");

        self::$articleRepository = NULL;
        self::$palletRepository = NULL;
        self::$purchaseOrderRepository = NULL;
        self::$purchaseOrderDetailRepository = NULL;
        self::$receiptHistoryRepository = NULL;
        self::$toteRepository = NULL;
        self::$upcRepository = NULL;
        self::$userActivityRepository = NULL;
        self::$locationRepository = NULL;
        self::$inventoryRepository = NULL;
    }

    public function testSelectPO()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Set up the expectation for the associate() method
        // to be called only once and with three strings as its parameters.
        self::$userActivityRepository->expects($this->once())
            ->method('associate')
            ->with($this->equalTo(self::$Purchase_Order), $this->equalTo(ConfigMock::$expectedKeys['ReceivePO']), $this->equalTo(LangMock::$expectedKeys['ReceivePO']));

        // invoke method
        $this->articleFlow->selectPO($this->purchaseOrder);

        // assert on results
        $this->assertEquals(ConfigMock::$expectedKeys['ReceivePO'], ConfigMock::$key);
        $this->assertEquals(1, ConfigMock::$count);
        $this->assertEquals(LangMock::$expectedKeys['ReceivePO'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    public function testSelectLocation()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Set up the expectation for the associate() method
        // to be called only once and with three strings as its parameters.
        self::$userActivityRepository->expects($this->once())
            ->method('associate')
            ->with($this->equalTo(self::$Location_Name), $this->equalTo(ConfigMock::$expectedKeys['ReceiveLocation']), $this->equalTo(LangMock::$expectedKeys['ReceiveLocation']));

        // invoke method
        $this->articleFlow->selectLocation($this->location);

        // assert on results
        $this->assertEquals(ConfigMock::$expectedKeys['ReceiveLocation'], ConfigMock::$key);
        $this->assertEquals(1, ConfigMock::$count);
        $this->assertEquals(LangMock::$expectedKeys['ReceiveLocation'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    public function testSelectArticle()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Set up the expectation for the associate() method
        // to be called only once and with three strings as its parameters.
        self::$userActivityRepository->expects($this->once())
            ->method('associate')
            ->with($this->equalTo(self::$PurchaseOrderDetail_objectID), $this->equalTo(ConfigMock::$expectedKeys['ReceiveArticle']), $this->equalTo(LangMock::$expectedKeys['ReceiveArticle']));

        // invoke method
        $this->articleFlow->selectArticle($this->purchaseOrderDetail, $this->article);

        // assert on results
        $this->assertEquals(ConfigMock::$expectedKeys['ReceiveArticle'], ConfigMock::$key);
        $this->assertEquals(1, ConfigMock::$count);
        $this->assertEquals(LangMock::$expectedKeys['ReceiveArticle'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    public function testSetPurchaseOrderDetailLocation()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Set up the expectation for the associate() method
        // to be called only once and with three strings as its parameters.
        self::$purchaseOrderDetailRepository->expects($this->once())
            ->method('update')
            ->with(self::$PurchaseOrderDetail_objectID, ['Location' => self::$Location_objectID]);

        // invoke method
        $this->articleFlow->setPurchaseOrderDetailLocation(self::$PurchaseOrderDetail_objectID, self::$Location_objectID);
    }

    public function testRequestReworkValue()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Create a map of arguments to return values.
        $find_returnMap = array(
            array('000'.__LINE__.'000', (object)['UPC' => self::$UPC]),
            array('000'.__LINE__.'001', (object)['UPC' => self::$UPC, 'rework' => '']),
            array('000'.__LINE__.'002', (object)['UPC' => self::$UPC, 'rework' => 'AnyValue']),
        );

        // setup articleRepository mock
        self::$articleRepository
            ->method('find')
            ->will($this->returnValueMap($find_returnMap));

        // invoke method
        $this->assertTrue($this->articleFlow->requestReworkValue($find_returnMap[0][0]), 'article does not have rework attribute.');

        $this->assertTrue($this->articleFlow->requestReworkValue($find_returnMap[1][0]), 'article has zero length rework attribute.');

        $this->assertFalse($this->articleFlow->requestReworkValue($find_returnMap[2][0]), 'article has rework attribute.');
    }

    public function testSetReworkValue()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        $rework = 'LIGHT';

        // Create a map of arguments to return values.
        $find_returnMap = array(
            array('000'.__LINE__.'000', (object)['UPC' => self::$UPC]),
            array('000'.__LINE__.'001', (object)['UPC' => self::$UPC, 'rework' => '']),
            array('000'.__LINE__.'002', (object)['UPC' => self::$UPC, 'rework' => 'AnyValue']),
        );
        $updated_article = (object)['UPC' => self::$UPC, 'rework' => $rework];
        $update_returnMap = array(
            array($find_returnMap[0][1], ['rework' => $rework], $updated_article),
            array($find_returnMap[1][1], ['rework' => $rework], $updated_article),
            array($find_returnMap[2][1], ['rework' => $rework], $updated_article),
        );

        // setup articleRepository mock
        self::$articleRepository
            ->method('find')
            ->will($this->returnValueMap($find_returnMap));
        self::$articleRepository
            ->method('update')
            ->will($this->returnValueMap($update_returnMap));

        // invoke method
        $this->assertEquals($updated_article, $this->articleFlow->setReworkValue($find_returnMap[0][0], $rework), 'article does not have rework attribute.');

        $this->assertEquals($updated_article, $this->articleFlow->setReworkValue($find_returnMap[1][0], $rework), 'article has zero length rework attribute.');

        $this->assertEquals($updated_article, $this->articleFlow->setReworkValue($find_returnMap[2][0], $rework), 'article has rework attribute.');
    }

    /*
     * Article Management Hub
     * Much of the work is UI related and can be found in the ReceiveArticleController.
     * Article Management includes methods such as RequestReworkValue, setReworkValue, etc.
     * Here we can test the receivedUPCsGrid method who's results populate the UI UPC grid.
     */

    public function testReceivedUPCsGrid_ZeroUPCs()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pod = (object) ['objectID' => '100'.__LINE__.'000', 'Expected_Qty' => 5];
        $articleID = '200'.__LINE__.'000';

        // prepare mock objects
        self::$purchaseOrderDetailRepository->expects($this->once())
            ->method('find')
            ->with($pod->objectID)
            ->willReturn($pod);

        self::$upcRepository->expects($this->once())
            ->method('getArticleUPCs')
            ->with($articleID)
            ->willReturn(array());

        // Stop here and mark this test as incomplete.
        $grid = $this->articleFlow->receivedUPCsGrid($pod->objectID, $articleID);

        // assert on results
        $this->assertEquals(0, count($grid), 'Zero UPCs should produce an empty array.');
    }

    public function testReceivedUPCsGrid_OneUPC()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pod = (object) ['objectID' => '100'.__LINE__.'000', 'Expected_Qty' => 5];
        $articleID = '200'.__LINE__.'000';
        $upc = (object) ['parentID' => $articleID, 'Quantity' => 3, 'objectID' => '300'.__LINE__.'000', 'Client_SKU' => '300'.__LINE__.'300'];

        // prepare mock objects
        self::$purchaseOrderDetailRepository->expects($this->once())
            ->method('find')
            ->with($pod->objectID)
            ->willReturn($pod);

        self::$upcRepository->expects($this->once())
            ->method('getArticleUPCs')
            ->with($articleID)
            ->willReturn(array($upc));

        self::$inventoryRepository->expects($this->once())
            ->method('quantityOn')
            ->willReturn(1);

        // Stop here and mark this test as incomplete.
        $grid = $this->articleFlow->receivedUPCsGrid($pod->objectID, $articleID);

        // assert on results
        $this->assertEquals(1, count($grid), 'One UPC should produce an one element array.');
        //TODO here we should test the calculated values
        //TODO Where to get tote and location from
        $this->assertEquals(ConfigMock::$expectedKeys['statusReceived'], ConfigMock::$key);
        $this->assertEquals(1, ConfigMock::$count);
    }

    public function testArticleReceiptScansUPC()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testArticleReceiptScansTote()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testArticleReceiptPutUPCinTote()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testCloseToteScansTote()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testCloseToteScansCart()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testCloseTotePutToteOnCart()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testIsArticleComplete()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }

    public function testMoreArticlesToReceive()
    {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        // Optional: Test anything here, if you want.
        $this->assertTrue(TRUE, 'This test has not been implemented yet.');

        // Stop here and mark this test as incomplete.
        $this->markTestIncomplete('This test has not been implemented yet.');
    }


}
