<?php
/**
 * Created by PhpStorm.
 * User: pneal
 * Date: 24/04/16
 * Time: 11:17 PM
 */

namespace tests\unit\App\vital40\Inventory;

use App\vital40\Inventory\ComingleRules;

global $debug;
$debug = false;

class LangMock {
    public static $expectedKeys = [
        'notCalled' => 'This method not called',
        'notSupported' => 'internal.errors.comingleRules.notSupported',
        'notFound' => 'internal.errors.notFound',
        'reserve' => 'internal.errors.comingleRules.reserve',
        'notMoveLocType' => 'internal.errors.comingleRules.notMoveLocType',
        'notMoveComingle' => 'internal.errors.comingleRules.notMoveComingle',
    ];
    public static $key = 'notCalled';
    public static $count = 0;
    public static function reset() {
        self::$key = 'notCalled';
        self::$count = 0;
    }
    public static function get($key, $arr=array(), $arr2=array()) {
        self::$key=$key;
        self::$count++;
        return $key;
    }
}
class_alias('tests\unit\App\vital40\Inventory\LangMock', 'Lang');

class LogMock {
    public static $messages = [];
    public static $count = 0;
    public static function reset() {
        self::$messages = [];
        self::$count = 0;
    }
    public static function debug($message, $arr=array()) {
        self::$messages[] = 'DEBUG   - '.$message;
        self::$count++;
    }
    public static function info($message, $arr=array()) {
        self::$messages[] = 'INFO    - '.$message;
        self::$count++;
    }
    public static function warning($message, $arr=array()) {
        self::$messages[] = 'WARNING - '.$message;
        self::$count++;
    }
    public static function dumpMessages() {
        global $debug;
        if($debug) {
            for($i = 0; $i < self::$count; $i++) {
                fwrite(STDOUT, self::$messages[$i]."\n");
            }
        }
    }
}
class_alias('tests\unit\App\vital40\Inventory\LogMock', 'Log');

class Article {
    public function __construct($lineNumber = __LINE__, $split = true) {
        $this->objectID = '500'.$lineNumber.'000';
        $this->Client_SKU = '0050'.$lineNumber;
        $this->Description = 'Article 0050'.$lineNumber;
        $this->split = $split;
    }
    public $objectID;
    public $Client_SKU;
    public $Description;
    public $split = true;
    public function isSplit() { return $this->split; }
    public function isComingled() { return ! $this->split; }
}

/**
 * Class ComingleRulesTest
 * @package tests\unit\App\vital40\Inventory
 *
 * Invoke this method using
 *   cd ~/laravel_projects/vital4.0
 *   phpunit tests/unit/app/vital40/Inventory/ComingleRulesTest
 */
class ComingleRulesTest extends \PHPUnit_Framework_TestCase {

    protected static $articleRepository;
    protected static $inventoryRepository;
    protected static $locationRepository;
    protected static $palletRepository;
    protected static $toteRepository;
    protected static $upcRepository;

    protected $comingleRules;

    public static function setUpBeforeClass() {
        global $debug;
        parent::setUpBeforeClass(); // TODO: Change the autogenerated stub
        if($debug) fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        self::$articleRepository = NULL;
        self::$inventoryRepository = NULL;
        self::$locationRepository = NULL;
        self::$palletRepository = NULL;
        self::$toteRepository = NULL;
        self::$upcRepository = NULL;
    }

    protected function setUp() {
        global $debug;
        parent::setUp(); // TODO: Change the autogenerated stub
        if($debug) fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        self::$articleRepository = $this->getMockBuilder('vital40\Repositories\ArticleRepositoryInterface')->getMock();
        self::$inventoryRepository = $this->getMockBuilder('vital3\Repositories\InventoryRepositoryInterface')->getMock();
        self::$locationRepository = $this->getMockBuilder('vital3\Repositories\LocationRepositoryInterface')->getMock();
        self::$palletRepository = $this->getMockBuilder('vital3\Repositories\PalletRepositoryInterface')->getMock();
        self::$toteRepository = $this->getMockBuilder('vital40\Repositories\ToteRepositoryInterface')->getMock();
        self::$upcRepository = $this->getMockBuilder('vital40\Repositories\UPCRepositoryInterface')->getMock();

        $this->comingleRules = new ComingleRules(
              self::$articleRepository
            , self::$inventoryRepository
            , self::$locationRepository
            , self::$palletRepository
            , self::$toteRepository
            , self::$upcRepository
        );

        LangMock::reset();
    }

    protected function tearDown() {
        global $debug;
        parent::tearDown(); // TODO: Change the autogenerated stub
        if($debug) fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");

        $this->comingleRules = NULL;
    }

    public static function tearDownAfterClass() {
        global $debug;
        parent::tearDownAfterClass(); // TODO: Change the autogenerated stub
        if($debug) fwrite(STDOUT, __METHOD__ . "(" . __LINE__ . ")\n");

        self::$articleRepository = NULL;
        self::$inventoryRepository = NULL;
        self::$locationRepository = NULL;
        self::$palletRepository = NULL;
        self::$toteRepository = NULL;
        self::$upcRepository = NULL;
    }

    /*
     * Verify the movement of this pallet into this location will not break comingling rules.
     *   Method under test: isPutPalletIntoLocationAllowed($palletID, $locationID)
     *
         * Comingling rules
         * ================
         * Comingling rules apply at the putting inventory into tote level.
         *
         * When asked to put a pallet into a location the following rules should be observed.
         * 1. Anything can be moved into an activity (includes TZone) location.
         * 2. An empty Pallet (does not contain inventory) may be put anywhere.
         * 3. Anything in reserve or an activity location may be moved to a reserve location.
         * 4. Any pallet in a pick face location can be moved into another pick face location.
     */

    /**
     * Expected behavior when $palletID is not found -> negative test
     * @test
     */
    public function PalletIntoLocation_palletID_not_found() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'RESERVE'];

        // prepare mock objects
        self::$locationRepository->expects($this->once())
            ->method('find')
            ->with($location->objectID)
            ->willReturn($location);

        // invoke method
        $this->comingleRules->isPutPalletIntoLocationAllowed('62000'.__LINE__, $location->objectID);

        // assert on results
        $this->assertEquals(LangMock::$expectedKeys['notFound'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * Expected behavior when $locationID is not found -> negative test
     * @test
     */
    public function PalletIntoLocation_locationID_not_found() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];

        // prepare mock objects
        self::$palletRepository->expects($this->once())
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);

        // invoke method
        $this->comingleRules->isPutPalletIntoLocationAllowed($pallet->objectID, '62000'.__LINE__);

        // assert on results
        $this->assertEquals(LangMock::$expectedKeys['notFound'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 1. Anything can be moved into an activity (includes TZone) location.
     * @test
     */
    public function PalletIntoLocation_move_into_activity() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'ACTIVITY'];

        // prepare mock objects
        self::$palletRepository->expects($this->once())
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);

        // prepare mock objects
        self::$locationRepository->expects($this->once())
            ->method('find')
            ->with($location->objectID)
            ->willReturn($location);

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet->objectID, $location->objectID);

        // assert on results
        $this->assertTrue($result, '1. Moved into an activity location');
    }

    /**
     * 2. An empty Pallet (does not contain inventory) may be put anywhere.
     * @test
     */
    public function PalletIntoLocation_move_empty_pallet() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'002', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'OPEN'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'PICK000'.__LINE__];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote1 = (object) ['objectID' => '200'.__LINE__.'002', 'Carton_ID' => '52 0024 0'.__LINE__, 'Status' => 'REPLEN'];
        $tote2 = (object) ['objectID' => '200'.__LINE__.'003', 'Carton_ID' => '53 0024 0'.__LINE__, 'Status' => 'PUTAWAY'];

        // Create a map of arguments to return values.
        $pallet_find_returnMap = array(
            array($pallet0->objectID, $pallet0),
            array($pallet1->objectID, $pallet1),
        );
        $tote_filterOn_returnMap = array(
            array(['container.parent' => $pallet0->objectID], 0, null),
            array(['container.parent' => $pallet1->objectID], 0, [$tote0, $tote1, $tote2]),
        );
        $inventory_quantityOn_returnMap = array(
            array(['container.parent' => $tote0->objectID], 0),
            array(['container.parent' => $tote1->objectID], 0),
            array(['container.parent' => $tote2->objectID], 0),
        );

        // prepare mock objects
        self::$palletRepository
            ->method('find')
            ->will($this->returnValueMap($pallet_find_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('find')
            ->with($location->objectID)
            ->willReturn($location);

        // prepare mock objects
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));

        LogMock::reset();
        LogMock::info('2a. An empty Pallet (no totes) may be put anywhere.');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet0->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, '2a. An empty Pallet (no totes) may be put anywhere.');

        // prepare mock objects
        self::$inventoryRepository
            ->method('quantityOn')
            ->will($this->returnValueMap($inventory_quantityOn_returnMap));

        LogMock::reset();
        LogMock::info('2b. An empty Pallet (empty totes) may be put anywhere.');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet1->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, '2b. An empty Pallet (empty totes) may be put anywhere.');
    }

    /**
     * 3. Anything in reserve or an activity location may be moved to a reserve location.
     *   Empty pallet has already been caught by # 2. above.
     *   For this one we need to test 5 situations
     *     - FWP.. cart not located
     *     - RES.. cart not located
     *     - RES.. cart in an activity location
     *     - pallet in a reserve location
     *     - pallet in a pick face -> negative test
     * @test
     */
    public function PalletIntoLocation_move_into_reserve() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $cart0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'FWP000'.__LINE__, 'Status' => 'OPEN'];
        $cart1 = (object) ['objectID' => '100'.__LINE__.'002', 'Pallet_ID' => 'RES000'.__LINE__, 'Status' => 'OPEN'];
        $cart2 = (object) ['objectID' => '100'.__LINE__.'003', 'Pallet_ID' => 'RES000'.__LINE__, 'Status' => 'OPEN'];
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'004', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'005', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'LOCK'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'RESERVE'];
        $location0 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'REPLEN PAD', 'LocType' => 'ACTIVITY'];
        $location1 = (object) ['objectID' => '000'.__LINE__.'002', 'Location_Name' => 'E-CC0'.__LINE__, 'LocType' => 'RESERVE'];
        $location2 = (object) ['objectID' => '000'.__LINE__.'003', 'Location_Name' => 'E-DD0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // Create a map of arguments to return values.
        $pallet_find_returnMap = array(
            array($cart0->objectID, $cart0),
            array($cart1->objectID, $cart1),
            array($cart2->objectID, $cart2),
            array($pallet0->objectID, $pallet0),
            array($pallet1->objectID, $pallet1),
        );
        $tote_filterOn_returnMap = array(
            array(['container.parent' => $cart0->objectID], 0, [$tote]),
            array(['container.parent' => $cart1->objectID], 0, [$tote]),
            array(['container.parent' => $cart2->objectID], 0, [$tote]),
            array(['container.parent' => $pallet0->objectID], 0, [$tote]),
            array(['container.parent' => $pallet1->objectID], 0, [$tote]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $cart0->objectID], 2, []),
            array(['container.child' => $cart1->objectID], 2, []),
            array(['container.child' => $cart2->objectID], 2, [$location0]),
            array(['container.child' => $pallet0->objectID], 2, [$location1]),
            array(['container.child' => $pallet1->objectID], 2, [$location2]),
        );

        // prepare mock objects
        self::$palletRepository
            ->method('find')
            ->will($this->returnValueMap($pallet_find_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('find')
            ->with($location->objectID)
            ->willReturn($location);
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        // prepare mock objects
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));

        // prepare mock objects
        self::$inventoryRepository
            ->method('quantityOn')
            ->with(['container.parent' => $tote->objectID])
            ->willReturn(1);

        LogMock::reset();
        LogMock::info('cart0 - FWP.. cart not located');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($cart0->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'cart0, 3b. Activity to reserve');

        LogMock::reset();
        LogMock::info('cart1 - RES.. cart not located');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($cart1->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'cart1, 3a. Reserve to reserve');

        LogMock::reset();
        LogMock::info('cart2 - RES.. cart in an activity location');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($cart2->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'cart2, 3b. Activity to reserve');

        LogMock::reset();
        LogMock::info('pallet0 - pallet in a reserve location');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet0->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'pallet0, 3a. Reserve to reserve');

        LogMock::reset();
        LogMock::info('pallet1, - pallet in a pick face -> negative test');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet1->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['reserve'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 4. Any pallet in a pick face location may be moved into another pick face location.
     *   Empty pallet has already been caught by # 2. above.
     *   Here we only need one positive and two negative tests
     *     - Pick Face into Pick Face
     *     - Activity into Pick Face -> negative test
     *     - Reserve into Pick Face -> negative test
     * @test
     */
    public function PalletIntoLocation_move_pick_to_pick() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'004', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'OPEN'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'005', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'OPEN'];
        $pallet2 = (object) ['objectID' => '100'.__LINE__.'006', 'Pallet_ID' => 'CC0'.__LINE__, 'Status' => 'OPEN'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $location0 = (object) ['objectID' => '000'.__LINE__.'003', 'Location_Name' => 'E-DD0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $location1 = (object) ['objectID' => '000'.__LINE__.'002', 'Location_Name' => 'E-CC0'.__LINE__, 'LocType' => 'RESERVE'];
        $location2 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'REPLEN PAD', 'LocType' => 'ACTIVITY'];
        $tote = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // Create a map of arguments to return values.
        $pallet_find_returnMap = array(
            array($pallet0->objectID, $pallet0),
            array($pallet1->objectID, $pallet1),
            array($pallet2->objectID, $pallet2),
        );
        $tote_filterOn_returnMap = array(
            array(['container.parent' => $pallet0->objectID], 0, [$tote]),
            array(['container.parent' => $pallet1->objectID], 0, [$tote]),
            array(['container.parent' => $pallet2->objectID], 0, [$tote]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $pallet0->objectID], 2, [$location0]),
            array(['container.child' => $pallet1->objectID], 2, [$location1]),
            array(['container.child' => $pallet2->objectID], 2, [$location2]),
        );

        // prepare mock objects
        self::$palletRepository
            ->method('find')
            ->will($this->returnValueMap($pallet_find_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('find')
            ->with($location->objectID)
            ->willReturn($location);
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        // prepare mock objects
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));

        // prepare mock objects
        self::$inventoryRepository
            ->method('quantityOn')
            ->with(['container.parent' => $tote->objectID])
            ->willReturn(1);

        LogMock::reset();
        LogMock::info('pallet0 - Pick Face into Pick Face');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet0->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'pallet0, 4. move pick into pick face location');

        LogMock::reset();
        LogMock::info('pallet1 - Activity into Pick Face -> negative test');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet1->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveLocType'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);

        LogMock::reset();
        LogMock::info('pallet2 - Reserve into Pick Face -> negative test');

        // invoke method
        $result = $this->comingleRules->isPutPalletIntoLocationAllowed($pallet2->objectID, $location->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveLocType'], LangMock::$key);
        $this->assertEquals(2, LangMock::$count);
    }




    /*
     * Verify the movement of a tote into a pallet will not break comingling rules.
     *   Method under test: isPutToteIntoPalletAllowed($toteID, $palletID)
     *
         * Comingling rules
         * ================
         * Comingling rules apply at the putting inventory into tote level.
         *
         * When asked to put a Tote onto a Pallet the following rules should be observed.
         * 1. Anything can be moved into an activity (includes TZone) location.
         * 2. An empty Tote (does not contain inventory) may be put anywhere.
         * 3. Anything in reserve or an activity location may be moved to a reserve location.
         * 4. Any tote in a pick face location may be moved onto another pallet in a pick face location.
     */

    /**
     * Expected behavior when $palletID is not found -> negative test
     * @test
     */
    public function ToteIntoPallet_toteID_not_found() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet = (object) ['objectID' => '100'.__LINE__.'004', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'OPEN'];

        // prepare mock objects
        self::$palletRepository->expects($this->once())
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);

        // invoke method
        $this->comingleRules->isPutToteIntoPalletAllowed('62000'.__LINE__, $pallet->objectID);

        // assert on results
        $this->assertEquals(LangMock::$expectedKeys['notFound'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * Expected behavior when $locationID is not found -> negative test
     * @test
     */
    public function ToteIntoPallet_palletID_not_found() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $tote = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // prepare mock objects
        self::$toteRepository->expects($this->once())
            ->method('find')
            ->with($tote->objectID)
            ->willReturn($tote);

        // invoke method
        $this->comingleRules->isPutToteIntoPalletAllowed($tote->objectID, '62000'.__LINE__);

        // assert on results
        $this->assertEquals(LangMock::$expectedKeys['notFound'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 1. Anything can be moved into an activity (includes TZone) location.
     * @test
     */
    public function ToteIntoPallet_move_into_activity() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $tote = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $pallet = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'ACTIVITY'];

        // prepare mock objects
        self::$toteRepository->expects($this->once())
            ->method('find')
            ->with($tote->objectID)
            ->willReturn($tote);

        // prepare mock objects
        self::$palletRepository->expects($this->once())
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);

        // prepare mock objects
        self::$locationRepository->expects($this->once())
            ->method('filterOn')
            ->with(['container.child' => $pallet->objectID], 2)
            ->willReturn([$location]);

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote->objectID, $pallet->objectID);

        // assert on results
        $this->assertTrue($result, '1. Moved into an activity location');
    }

    /**
     * 2. An empty Pallet (does not contain inventory) may be put anywhere.
     * @test
     */
    public function ToteIntoPallet_move_empty_pallet() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $tote = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $pallet = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'PICK000'.__LINE__];

        // prepare mock objects
        self::$toteRepository
            ->method('find')
            ->with($tote->objectID)
            ->willReturn($tote);

        // prepare mock objects
        self::$palletRepository
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);

        // prepare mock objects
        self::$locationRepository->expects($this->once())
            ->method('filterOn')
            ->with(['container.child' => $pallet->objectID], 2)
            ->willReturn([$location]);

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->with($tote->objectID)
            ->willReturn(true);

        LogMock::reset();
        LogMock::info('2. An empty Tote may be put anywhere.');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, '2. An empty Tote may be put anywhere.');
    }

    /**
     * 3. Anything in reserve or an activity location may be moved to a reserve location.
     *   Empty pallet has already been caught by # 2. above.
     *   For this one we need to test 5 situations
     *     - tote on a FWP.. cart not located
     *     - tote on a RES.. cart not located
     *     - tote on a RES.. cart in an activity location
     *     - tote on a pallet in a reserve location
     *     - tote on a pallet in a pick face -> negative test
     * @test
     */
    public function ToteIntoPallet_move_into_reserve() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $cart0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'FWP000'.__LINE__, 'Status' => 'OPEN'];
        $cart1 = (object) ['objectID' => '100'.__LINE__.'002', 'Pallet_ID' => 'RES000'.__LINE__, 'Status' => 'OPEN'];
        $cart2 = (object) ['objectID' => '100'.__LINE__.'003', 'Pallet_ID' => 'RES000'.__LINE__, 'Status' => 'OPEN'];
        $pallet = (object) ['objectID' => '100'.__LINE__.'004', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'005', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'LOCK'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'006', 'Pallet_ID' => 'CC0'.__LINE__, 'Status' => 'LOCK'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'RESERVE'];
        $location0 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'REPLEN PAD', 'LocType' => 'ACTIVITY'];
        $location1 = (object) ['objectID' => '000'.__LINE__.'002', 'Location_Name' => 'E-CC0'.__LINE__, 'LocType' => 'RESERVE'];
        $location2 = (object) ['objectID' => '000'.__LINE__.'003', 'Location_Name' => 'E-DD0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote1 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote2 = (object) ['objectID' => '200'.__LINE__.'002', 'Carton_ID' => '52 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote3 = (object) ['objectID' => '200'.__LINE__.'003', 'Carton_ID' => '53 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote4 = (object) ['objectID' => '200'.__LINE__.'004', 'Carton_ID' => '54 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // Create a map of arguments to return values.
        $tote_find_returnMap = array(
            array($tote0->objectID, $tote0),
            array($tote1->objectID, $tote1),
            array($tote2->objectID, $tote2),
            array($tote3->objectID, $tote3),
            array($tote4->objectID, $tote4),
        );
        $tote_filterOn_returnMap = array(
            array(['container.parent' => $cart0->objectID], 0, [$tote0]),
            array(['container.parent' => $cart1->objectID], 0, [$tote1]),
            array(['container.parent' => $cart2->objectID], 0, [$tote2]),
            array(['container.parent' => $pallet0->objectID], 0, [$tote3]),
            array(['container.parent' => $pallet1->objectID], 0, [$tote4]),
        );
        $pallet_filterOn_returnMap = array(
            array(['container.child' => $tote0->objectID], 2, [$cart0]),
            array(['container.child' => $tote1->objectID], 2, [$cart1]),
            array(['container.child' => $tote2->objectID], 2, [$cart2]),
            array(['container.child' => $tote3->objectID], 2, [$pallet0]),
            array(['container.child' => $tote4->objectID], 2, [$pallet1]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $pallet->objectID], 2, [$location]),
            array(['container.child' => $cart0->objectID], 2, []),
            array(['container.child' => $cart1->objectID], 2, []),
            array(['container.child' => $cart2->objectID], 2, [$location0]),
            array(['container.child' => $pallet0->objectID], 2, [$location1]),
            array(['container.child' => $pallet1->objectID], 2, [$location2]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('find')
            ->will($this->returnValueMap($tote_find_returnMap));
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$palletRepository
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);
        self::$palletRepository
            ->method('filterOn')
            ->will($this->returnValueMap($pallet_filterOn_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        LogMock::reset();
        LogMock::info('tote0 - tote on a FWP.. cart not located');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote0->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'tote0, 3b. Activity to reserve');

        LogMock::reset();
        LogMock::info('tote1 - tote on a RES.. cart not located');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote1->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'tote1, 3a. Reserve to reserve');

        LogMock::reset();
        LogMock::info('tote2 - tote on a RES.. cart in an activity location');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote2->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'tote2, 3b. Activity to reserve');

        LogMock::reset();
        LogMock::info('tote3 - tote on a pallet in a reserve location');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote3->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'tote3, 3a. Reserve to reserve');

        LogMock::reset();
        LogMock::info('tote4 - tote on a pallet in a pick face -> negative test');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote4->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['reserve'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 4. Any tote in a pick face location may be moved onto another pallet in a pick face location.
     *   Empty pallet has already been caught by # 2. above.
     *   Here we only need one positive and two negative tests
     *     - tote in a Pick Face into Pick Face
     *     - tote in an Activity into Pick Face -> negative test
     *     - tote in a Reserve into Pick Face -> negative test
     * @test
     */
    public function ToteIntoPallet_move_pick_to_pick() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet = (object) ['objectID' => '100'.__LINE__.'000', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'OPEN'];
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'OPEN'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'002', 'Pallet_ID' => 'CC0'.__LINE__, 'Status' => 'OPEN'];
        $pallet2 = (object) ['objectID' => '100'.__LINE__.'003', 'Pallet_ID' => 'DD0'.__LINE__, 'Status' => 'OPEN'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $location0 = (object) ['objectID' => '000'.__LINE__.'003', 'Location_Name' => 'E-BB0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $location1 = (object) ['objectID' => '000'.__LINE__.'002', 'Location_Name' => 'E-CC0'.__LINE__, 'LocType' => 'RESERVE'];
        $location2 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'REPLEN PAD', 'LocType' => 'ACTIVITY'];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote1 = (object) ['objectID' => '200'.__LINE__.'002', 'Carton_ID' => '52 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote2 = (object) ['objectID' => '200'.__LINE__.'003', 'Carton_ID' => '53 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // Create a map of arguments to return values.
        $tote_find_returnMap = array(
            array($tote0->objectID, $tote0),
            array($tote1->objectID, $tote1),
            array($tote2->objectID, $tote2),
        );
        $tote_filterOn_returnMap = array(
            array(['container.parent' => $pallet0->objectID], 0, [$tote]),
            array(['container.parent' => $pallet1->objectID], 0, [$tote]),
            array(['container.parent' => $pallet2->objectID], 0, [$tote]),
        );
        $pallet_filterOn_returnMap = array(
            array(['container.child' => $tote0->objectID], 2, [$pallet0]),
            array(['container.child' => $tote1->objectID], 2, [$pallet1]),
            array(['container.child' => $tote2->objectID], 2, [$pallet2]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $pallet->objectID], 2, [$location]),
            array(['container.child' => $pallet0->objectID], 2, [$location0]),
            array(['container.child' => $pallet1->objectID], 2, [$location1]),
            array(['container.child' => $pallet2->objectID], 2, [$location2]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('find')
            ->will($this->returnValueMap($tote_find_returnMap));
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$palletRepository
            ->method('find')
            ->with($pallet->objectID)
            ->willReturn($pallet);
        self::$palletRepository
            ->method('filterOn')
            ->will($this->returnValueMap($pallet_filterOn_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        LogMock::reset();
        LogMock::info('tote0 - tote in a Pick Face into Pick Face');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote0->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'tote0, 4. move pick into pick face location');

        LogMock::reset();
        LogMock::info('tote1 - tote in an Activity into Pick Face -> negative test');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote1->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveLocType'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);

        LogMock::reset();
        LogMock::info('tote2 - tote in a Reserve into Pick Face -> negative test');

        // invoke method
        $result = $this->comingleRules->isPutToteIntoPalletAllowed($tote2->objectID, $pallet->objectID);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveLocType'], LangMock::$key);
        $this->assertEquals(2, LangMock::$count);
    }




    /*
     * Verifies the movement of inventory into a tote will not break comingling rules.
     *   Method under test: isPutInventoryIntoToteAllowed($inventoryID, $toteID)
     *
         * Comingling rules
         * ================
         * Comingling rules apply at the putting inventory into tote level.
         *
         * When asked to put Inventory into a Tote the following rules should be observed.
         * It must adhere to the Comingling at the Inventory Level Rules
         * and must adhere to the Inventory Movement at the LocType Level Rules
     */

    /**
     * Expected behavior when $inventoryID is not found -> negative test
     * @test
     */
    public function InventoryIntoTote_inventoryID_not_found() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // prepare mock objects
        self::$toteRepository->expects($this->once())
            ->method('find')
            ->with($tote->objectID)
            ->willReturn($tote);

        // invoke method
        $this->comingleRules->isPutInventoryIntoToteAllowed('300'.__LINE__.'000', $tote->objectID);

        // assert on results
        $this->assertEquals(LangMock::$expectedKeys['notFound'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * Expected behavior when $toteID is not found -> negative test
     * @test
     */
    public function InventoryIntoTote_toteID_not_found() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $inventory = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => '62040'.__LINE__, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];

        // prepare mock objects
        self::$inventoryRepository->expects($this->once())
            ->method('find')
            ->with($inventory->objectID)
            ->willReturn($inventory);

        // invoke method
        $this->comingleRules->isPutInventoryIntoToteAllowed($inventory->objectID, '200'.__LINE__.'000');

        // assert on results
        $this->assertEquals(LangMock::$expectedKeys['notFound'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }




    /*
     * It must adhere to the Comingling at the Inventory Level Rules
     *   Method under test: cominglingAtTheInventoryLevelRules($inventory, $tote)
     *
     * At this point we can ignore the LocType of the inventory and the tote, as these will be addressed in the next testing group.
     * We should only concern ourselves here with the relationship of the moving inventory and the inventory already in the tote.
     *
         * Comingling at the Inventory Level Rules
         * 1. Inventory can be placed into an empty tote.
         * 2. Inventory can be placed into a tote that contains ONLY that same Item/UPC.
         * 3. Comingleable Inventory can be placed into a tote that contains Inventory of the same Article
         * 4. Comingleable Inventory can be placed into a tote that contains Inventory of any comingled Article that includes this same Item/UPC.
     */

    /**
     * 1. Inventory can be placed into an empty tote.
     * @test
     */
    public function InventoryIntoTote_into_empty_tote() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $inventory = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => '62040'.__LINE__, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0024 0'.__LINE__, 'Status' => 'OPEN'];

        // prepare mock objects
        self::$toteRepository->expects($this->once())
            ->method('isEmpty')
            ->with($tote->objectID)
            ->willReturn(true);

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        $this->assertTrue($result, '1. Inventory can be placed into an empty tote.');
    }

    /**
     * 2. Inventory can be placed into a tote that contains ONLY that same Item/UPC.
     *   One positive and one negative test should suffice
     *   - upc of moving inventory == upc of inventory in the tote
     *   - upc of moving inventory != upc of inventory in the tote (not comingled)
     * @test
     */
    public function InventoryIntoTote_in_with_same_UPC() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc0 = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'Joe Fresh UPC: 0040'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Joe Fresh UPC: 0041'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => $upc0->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 0'.__LINE__, 'Status' => 'OPEN'];
        $tote1 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '50 0021 0'.__LINE__, 'Status' => 'OPEN'];

        $article = new Article(__LINE__);

        // Create a map of arguments to return values.
        $tote_isEmpty_returnMap = array(
            array($tote0->objectID, false),
            array($tote1->objectID, false),
        );
        $upc_getToteUPCs_returnMap = array(
            array($tote0->objectID, 0, [$upc0]),
            array($tote1->objectID, 0, [$upc1]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->will($this->returnValueMap($tote_isEmpty_returnMap));

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->will($this->returnValueMap($upc_getToteUPCs_returnMap));

        // prepare mock objects
        self::$articleRepository->expects($this->once())
            ->method('getUPCArticles')
            ->with($inventory->Item, 0)
            ->willReturn([$article]);

        LogMock::reset();
        LogMock::info('inventory, tote0 - upc of moving inventory == upc of inventory in the tote');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote0);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'tote0, 2. Inventory can be placed with same Item/UPC.');

        LogMock::reset();
        LogMock::info('inventory, tote1 - upc of moving inventory != upc of inventory in the tote (not comingled)');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote1);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveComingle'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 3. Comingleable Inventory can be placed into a tote that contains Inventory of the same Article
     *   One positive and one negative test should suffice
     *   P0 - upc of moving inventory is of the article for the inventory in the tote
     *   N0 - upc of moving inventory of a different article.
     * @test
     */
    public function InventoryIntoTote_comingle_with_same_Article_P0() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'XSmall UPC: 0040'.__LINE__];
        $upc0 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Small UPC: 0041'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'002', 'Client_SKU' => '0042'.__LINE__, 'Description' => 'Medium UPC: 0042'.__LINE__];
        $upc2 = (object) ['objectID' => '400'.__LINE__.'003', 'Client_SKU' => '0043'.__LINE__, 'Description' => 'Large UPC: 0043'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => $upc->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 '.__LINE__, 'Status' => 'OPEN'];

        $article0 = new Article(__LINE__, false);

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->with($tote->objectID)
            ->willReturn(false);

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->with($tote->objectID, 0)
            ->willReturn([$upc0,$upc1,$upc2]);
        self::$upcRepository
            ->method('getArticleUPCs')
            ->with($article0->objectID, 0)
            ->willReturn([$upc,$upc0,$upc1,$upc2]);

        // prepare mock objects
        self::$articleRepository
            ->method('getUPCArticles')
            ->willReturn([$article0]);

        LogMock::reset();
        LogMock::info('P0 - upc of moving inventory is of the article for the inventory in the tote');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'P0, 3. Comingleable Inventory with Inventory of the same Article');
    }

    /**
     * 3. Comingleable Inventory can be placed into a tote that contains Inventory of the same Article
     *   One positive and one negative test should suffice
     *   - upc of moving inventory is of the article for the inventory in the tote
     *   - upc of moving inventory of a different article.
     * @test
     */
    public function InventoryIntoTote_comingle_with_same_Article_N0() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'XSmall UPC: 0040'.__LINE__];
        $upc0 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Small UPC: 0041'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'002', 'Client_SKU' => '0042'.__LINE__, 'Description' => 'Medium UPC: 0042'.__LINE__];
        $upc2 = (object) ['objectID' => '400'.__LINE__.'003', 'Client_SKU' => '0043'.__LINE__, 'Description' => 'Large UPC: 0043'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => $upc->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 '.__LINE__, 'Status' => 'OPEN'];

        $article0 = new Article(__LINE__, false);
        $article1 = new Article(__LINE__, false);

        // Create a map of arguments to return values.
        $upc_getArticleUPCs_returnMap = array(
            array($article0->objectID, 0, [$upc]),
            array($article1->objectID, 0, [$upc0,$upc1,$upc2]),
        );
        $article_getUPCArticles_returnMap = array(
            array($upc->objectID, 0, [$article0]),
            array($upc0->objectID, 0, [$article1]),
            array($upc1->objectID, 0, [$article1]),
            array($upc2->objectID, 0, [$article1]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->with($tote->objectID)
            ->willReturn(false);

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->with($tote->objectID, 0)
            ->willReturn([$upc0,$upc1,$upc2]);
        self::$upcRepository
            ->method('getArticleUPCs')
            ->will($this->returnValueMap($upc_getArticleUPCs_returnMap));

        // prepare mock objects
        self::$articleRepository
            ->method('getUPCArticles')
            ->will($this->returnValueMap($article_getUPCArticles_returnMap));

        LogMock::reset();
        LogMock::info('N0 - upc of moving inventory of a different article.');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveComingle'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 4. Comingleable Inventory can be placed into a tote that contains Inventory of any comingled Article that includes this same Item/UPC.
     *   What the ___ does that mean?
     *   Well remember that the same upc may be included in multiple articles, with different quantities.
     *
     * Consider a situation where our tote already contains inventory of [$upc0,$upc1,$upc2]
     *   and we are asked for permission to put into this tote inventory of article $upc.
     *   If the article has [$upc,$upc0,$upc1,$upc2], we accept the request as shown in test # 3. above, so we may ignore it here.
     *
     * Now lets define a few articles
     *   Article A has 2 of $upc0 and 2 of $upc1    <== with A alone, we must reject the request
     *   Article B has 1 of $upc and 3 of $upc3     <== with A and B we still must reject the request
     *   Article C has 1 of $upc0, 1 of $upc2 and 2 of $upc3    <== with A, B and C, we can now accept the inventory request
     *
     * Negative tests
     * N0 - upc of moving inventory is not comingled
     * N1 - all comingled, add Article A
     * N2 - all comingled, add Article A and B
     * Positive test
     * P0 - all comingled, add Article A, B and C
     * @test
     */
    public function InventoryIntoTote_comingle_with_including_Article_N0() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'XSmall UPC: 0040'.__LINE__];
        $upc0 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Small UPC: 0041'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'002', 'Client_SKU' => '0042'.__LINE__, 'Description' => 'Medium UPC: 0042'.__LINE__];
        $upc2 = (object) ['objectID' => '400'.__LINE__.'003', 'Client_SKU' => '0043'.__LINE__, 'Description' => 'Large UPC: 0043'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => $upc->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 '.__LINE__, 'Status' => 'OPEN'];

        $articleIsSplit = new Article(__LINE__, true);

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->with($tote->objectID, 0)
            ->willReturn([$upc0,$upc1,$upc2]);

        // prepare mock objects
        self::$articleRepository
            ->method('getUPCArticles')
            ->with($upc->objectID, 0)
            ->willReturn([$articleIsSplit]);

        LogMock::reset();
        LogMock::info('Negative test, N0 - upc of moving inventory is not comingled');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveComingle'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * Now lets define a few articles
     *   Article A has 2 of $upc0 and 2 of $upc1    <== with A alone, we must reject the request
     *
     * Negative test
     * N1 - all comingled, add Article A
     * @test
     */
    public function InventoryIntoTote_comingle_with_including_Article_N1() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'XSmall UPC: 0040'.__LINE__];
        $upc0 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Small UPC: 0041'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'002', 'Client_SKU' => '0042'.__LINE__, 'Description' => 'Medium UPC: 0042'.__LINE__];
        $upc2 = (object) ['objectID' => '400'.__LINE__.'003', 'Client_SKU' => '0043'.__LINE__, 'Description' => 'Large UPC: 0043'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => $upc->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 '.__LINE__, 'Status' => 'OPEN'];

        $article = new Article(__LINE__, false);
        $articleA = new Article(__LINE__, false);

        // Create a map of arguments to return values.
        $upc_getArticleUPCs_returnMap = array(
            array($article->objectID, 0, [$upc]),
            array($articleA->objectID, 0, [$upc0,$upc1,$upc2]),
        );
        $article_getUPCArticles_returnMap = array(
            array($upc->objectID, 0, [$article]),
            array($upc0->objectID, 0, [$articleA]),
            array($upc1->objectID, 0, [$articleA]),
            array($upc2->objectID, 0, [$articleA]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->with($tote->objectID, 0)
            ->willReturn([$upc0,$upc1,$upc2]);
        self::$upcRepository
            ->method('getArticleUPCs')
            ->will($this->returnValueMap($upc_getArticleUPCs_returnMap));

        // prepare mock objects
        self::$articleRepository
            ->method('getUPCArticles')
            ->will($this->returnValueMap($article_getUPCArticles_returnMap));

        LogMock::reset();
        LogMock::info('Negative test, N1 - all comingled, add Article A');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveComingle'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * Now lets define a few articles
     *   Article A has 2 of $upc0 and 2 of $upc1    <== with A alone, we must reject the request
     *   Article B has 1 of $upc and 3 of $upc3     <== with A and B we still must reject the request
     *
     * Negative test
     * N2 - all comingled, add Article A and B
     * @test
     */
    public function InventoryIntoTote_comingle_with_including_Article_N2() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'upc UPC: 0045'.__LINE__];
        $upc0 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Small UPC: 0041'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'002', 'Client_SKU' => '0042'.__LINE__, 'Description' => 'Medium UPC: 0042'.__LINE__];
        $upc2 = (object) ['objectID' => '400'.__LINE__.'003', 'Client_SKU' => '0043'.__LINE__, 'Description' => 'Large UPC: 0043'.__LINE__];
        $upc3 = (object) ['objectID' => '400'.__LINE__.'004', 'Client_SKU' => '0044'.__LINE__, 'Description' => 'Large UPC: 0044'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => $upc->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 '.__LINE__, 'Status' => 'OPEN'];

        $article = new Article(__LINE__, false);
        $articleA = new Article(__LINE__, false);
        $articleB = new Article(__LINE__, false);

        // Create a map of arguments to return values.
        $upc_getArticleUPCs_returnMap = array(
            array($article->objectID, 0, [$upc2]),
            array($articleA->objectID, 0, [$upc0,$upc1]),
            array($articleB->objectID, 0, [$upc,$upc3]),
        );
        $article_getUPCArticles_returnMap = array(
            array($upc->objectID, 0, [$articleB]),
            array($upc0->objectID, 0, [$articleA]),
            array($upc1->objectID, 0, [$articleA]),
            array($upc2->objectID, 0, [$article]),
            array($upc3->objectID, 0, [$articleB]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->with($tote->objectID, 0)
            ->willReturn([$upc0,$upc1,$upc2]);
        self::$upcRepository
            ->method('getArticleUPCs')
            ->will($this->returnValueMap($upc_getArticleUPCs_returnMap));

        // prepare mock objects
        self::$articleRepository
            ->method('getUPCArticles')
            ->will($this->returnValueMap($article_getUPCArticles_returnMap));

        LogMock::reset();
        LogMock::info('Negative test, N2 - all comingled, add Article A and B');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveComingle'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * Now lets define a few articles
     *   Article A has 2 of $upc0 and 2 of $upc1    <== with A alone, we must reject the request
     *   Article B has 1 of $upc and 3 of $upc3     <== with A and B we still must reject the request
     *   Article C has 1 of $upc0, 1 of $upc2 and 2 of $upc3    <== with A, B and C, we can now accept the inventory request
     *
     * Positive test
     * P0 - all comingled, add Article A, B and C
     * @test
     */
    public function InventoryIntoTote_comingle_with_including_Article_P0() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $upc = (object) ['objectID' => '400'.__LINE__.'000', 'Client_SKU' => '0040'.__LINE__, 'Description' => 'upc UPC: 0045'.__LINE__];
        $upc0 = (object) ['objectID' => '400'.__LINE__.'001', 'Client_SKU' => '0041'.__LINE__, 'Description' => 'Small UPC: 0041'.__LINE__];
        $upc1 = (object) ['objectID' => '400'.__LINE__.'002', 'Client_SKU' => '0042'.__LINE__, 'Description' => 'Medium UPC: 0042'.__LINE__];
        $upc2 = (object) ['objectID' => '400'.__LINE__.'003', 'Client_SKU' => '0043'.__LINE__, 'Description' => 'Large UPC: 0043'.__LINE__];
        $upc3 = (object) ['objectID' => '400'.__LINE__.'004', 'Client_SKU' => '0044'.__LINE__, 'Description' => 'Large UPC: 0044'.__LINE__];
        $inventory = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => $upc->objectID, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 '.__LINE__, 'Status' => 'OPEN'];

        $articleA = new Article(__LINE__, false);
        $articleB = new Article(__LINE__, false);
        $articleC = new Article(__LINE__, false);

        // Create a map of arguments to return values.
        $upc_getArticleUPCs_returnMap = array(
            array($articleA->objectID, 0, [$upc0,$upc1]),
            array($articleB->objectID, 0, [$upc,$upc3]),
            array($articleC->objectID, 0, [$upc0,$upc2,$upc3]),
        );
        $article_getUPCArticles_returnMap = array(
            array($upc->objectID, 0, [$articleB]),
            array($upc0->objectID, 0, [$articleA,$articleC]),
            array($upc1->objectID, 0, [$articleA]),
            array($upc2->objectID, 0, [$articleC]),
            array($upc3->objectID, 0, [$articleB,$articleC]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$upcRepository
            ->method('getToteUPCs')
            ->with($tote->objectID, 0)
            ->willReturn([$upc0,$upc1,$upc2]);
        self::$upcRepository
            ->method('getArticleUPCs')
            ->will($this->returnValueMap($upc_getArticleUPCs_returnMap));

        // prepare mock objects
        self::$articleRepository
            ->method('getUPCArticles')
            ->will($this->returnValueMap($article_getUPCArticles_returnMap));

        LogMock::reset();
        LogMock::info('Positive test, P0 - all comingled, add Article A, B and C');

        // invoke method
        $result = $this->comingleRules->cominglingAtTheInventoryLevelRules($inventory, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'Positive test, P0 - all comingled, add Article A, B and C');
    }




    /*
     * ... and must adhere to the Inventory Movement at the LocType Level Rules
     *   Method under test: inventoryMovementAtTheLocTypeLevelRules($inventory, $tote)
     *
     * At this point we must verify inventory movement based on the LocType of the inventory and the tote.
     * The previous test group has already verified the relationship of the moving inventory and the inventory already in the tote.
     *
         * Inventory Movement at the LocType Level Rules
         * 1. Anything can be moved into an activity (includes TZone) location.
         * 2. Anything in reserve or an activity location can be moved to a reserve location.
         * 3. Inventory in a pick face location can be moved into another tote in a pick face location.
     */


    /**
     * 1. Anything can be moved into an activity (includes TZone) location.
     * @test
     */
    public function InventoryIntoTote_move_into_activity() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $inventory = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => '62040'.__LINE__, 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0020 0'.__LINE__, 'Status' => 'OPEN'];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '50 0021 0'.__LINE__, 'Status' => 'OPEN'];
        $pallet = (object) ['objectID' => '100'.__LINE__.'000', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'PUTAWAY'];
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'PUTAWAY'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'ACTIVITY'];
        $location0 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'E-BB0'.__LINE__, 'LocType' => 'ACTIVITY'];

        // Create a map of arguments to return values.
        $pallet_filterOn_returnMap = array(
            array(['container.child' => $tote->objectID], 2, [$pallet]),
            array(['container.child' => $tote0->objectID], 2, [$pallet0]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $pallet->objectID], 2, [$location]),
            array(['container.child' => $pallet0->objectID], 2, [$location0]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('filterOn')
            ->with(['container.child' => $inventory->objectID], 2)
            ->willReturn([$tote]);

        // prepare mock objects
        self::$palletRepository
            ->method('filterOn')
            ->will($this->returnValueMap($pallet_filterOn_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory, $tote0);

        // assert on results
        $this->assertTrue($result, '1. Moved into an activity location');
    }

    /**
     * 2. Anything in reserve or an activity location can be moved to a reserve location.
     *   For this one we need to test 5 situations
     *     - inventory on a FWP.. cart not located
     *     - inventory on a RES.. cart not located
     *     - inventory on a RES.. cart in an activity location
     *     - inventory in a reserve location
     *     - inventory in a pick face -> negative test
     * @test
     */
    public function InventoryIntoTote_move_into_reserve() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $cart0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'FWP000'.__LINE__, 'Status' => 'OPEN'];
        $cart1 = (object) ['objectID' => '100'.__LINE__.'002', 'Pallet_ID' => 'RES000'.__LINE__, 'Status' => 'OPEN'];
        $cart2 = (object) ['objectID' => '100'.__LINE__.'003', 'Pallet_ID' => 'RES000'.__LINE__, 'Status' => 'OPEN'];
        $pallet = (object) ['objectID' => '100'.__LINE__.'004', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'LOCK'];
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'005', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'LOCK'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'006', 'Pallet_ID' => 'CC0'.__LINE__, 'Status' => 'LOCK'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'RESERVE'];
        $location0 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'REPLEN PAD', 'LocType' => 'ACTIVITY'];
        $location1 = (object) ['objectID' => '000'.__LINE__.'002', 'Location_Name' => 'E-CC0'.__LINE__, 'LocType' => 'RESERVE'];
        $location2 = (object) ['objectID' => '000'.__LINE__.'003', 'Location_Name' => 'E-DD0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote1 = (object) ['objectID' => '200'.__LINE__.'002', 'Carton_ID' => '52 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote2 = (object) ['objectID' => '200'.__LINE__.'003', 'Carton_ID' => '53 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote3 = (object) ['objectID' => '200'.__LINE__.'004', 'Carton_ID' => '54 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote4 = (object) ['objectID' => '200'.__LINE__.'005', 'Carton_ID' => '55 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $inventory0 = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => '400'.__LINE__.'000', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $inventory1 = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => '400'.__LINE__.'001', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $inventory2 = (object) ['objectID' => '300'.__LINE__.'002', 'Item' => '400'.__LINE__.'002', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $inventory3 = (object) ['objectID' => '300'.__LINE__.'003', 'Item' => '400'.__LINE__.'003', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $inventory4 = (object) ['objectID' => '300'.__LINE__.'004', 'Item' => '400'.__LINE__.'004', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];

        // Create a map of arguments to return values.
        $tote_filterOn_returnMap = array(
            array(['container.child' => $inventory0->objectID], 2, [$tote0]),
            array(['container.child' => $inventory1->objectID], 2, [$tote1]),
            array(['container.child' => $inventory2->objectID], 2, [$tote2]),
            array(['container.child' => $inventory3->objectID], 2, [$tote3]),
            array(['container.child' => $inventory4->objectID], 2, [$tote4]),
        );
        $pallet_filterOn_returnMap = array(
            array(['container.child' => $tote->objectID], 2, [$pallet]),
            array(['container.child' => $tote0->objectID], 2, [$cart0]),
            array(['container.child' => $tote1->objectID], 2, [$cart1]),
            array(['container.child' => $tote2->objectID], 2, [$cart2]),
            array(['container.child' => $tote3->objectID], 2, [$pallet0]),
            array(['container.child' => $tote4->objectID], 2, [$pallet1]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $pallet->objectID], 2, [$location]),
            array(['container.child' => $cart0->objectID], 2, []),
            array(['container.child' => $cart1->objectID], 2, []),
            array(['container.child' => $cart2->objectID], 2, [$location0]),
            array(['container.child' => $pallet0->objectID], 2, [$location1]),
            array(['container.child' => $pallet1->objectID], 2, [$location2]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$palletRepository
            ->method('filterOn')
            ->will($this->returnValueMap($pallet_filterOn_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        LogMock::reset();
        LogMock::info('inventory0 - inventory on a FWP.. cart not located');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory0, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'inventory0, 2b. Activity to reserve');

        LogMock::reset();
        LogMock::info('inventory1 - inventory on a RES.. cart not located');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory1, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'inventory1, 2a. Reserve to reserve');

        LogMock::reset();
        LogMock::info('inventory2 - inventory on a RES.. cart in an activity location');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory2, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'inventory2, 2b. Activity to reserve');

        LogMock::reset();
        LogMock::info('inventory3 - inventory in a reserve location');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory3, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'inventory3, 2a. Reserve to reserve');

        LogMock::reset();
        LogMock::info('inventory4 - inventory in a pick face -> negative test');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory4, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['reserve'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);
    }

    /**
     * 3. Inventory in a pick face location can be moved into another tote in a pick face location.
     *   Here we only need one positive and two negative tests
     *     - tote in a Pick Face into Pick Face
     *     - tote in an Activity into Pick Face -> negative test
     *     - tote in a Reserve into Pick Face -> negative test
     * @test
     */
    public function InventoryIntoTote_move_pick_to_pick() {
        fwrite(STDOUT, __METHOD__."(".__LINE__.")\n");
        $pallet = (object) ['objectID' => '100'.__LINE__.'000', 'Pallet_ID' => 'AA0'.__LINE__, 'Status' => 'OPEN'];
        $pallet0 = (object) ['objectID' => '100'.__LINE__.'001', 'Pallet_ID' => 'BB0'.__LINE__, 'Status' => 'OPEN'];
        $pallet1 = (object) ['objectID' => '100'.__LINE__.'002', 'Pallet_ID' => 'CC0'.__LINE__, 'Status' => 'OPEN'];
        $pallet2 = (object) ['objectID' => '100'.__LINE__.'003', 'Pallet_ID' => 'DD0'.__LINE__, 'Status' => 'OPEN'];
        $location = (object) ['objectID' => '000'.__LINE__.'000', 'Location_Name' => 'E-AA0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $location0 = (object) ['objectID' => '000'.__LINE__.'003', 'Location_Name' => 'E-BB0'.__LINE__, 'LocType' => 'PICK00'.__LINE__];
        $location1 = (object) ['objectID' => '000'.__LINE__.'002', 'Location_Name' => 'E-CC0'.__LINE__, 'LocType' => 'RESERVE'];
        $location2 = (object) ['objectID' => '000'.__LINE__.'001', 'Location_Name' => 'REPLEN PAD', 'LocType' => 'ACTIVITY'];
        $tote = (object) ['objectID' => '200'.__LINE__.'000', 'Carton_ID' => '50 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote0 = (object) ['objectID' => '200'.__LINE__.'001', 'Carton_ID' => '51 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote1 = (object) ['objectID' => '200'.__LINE__.'002', 'Carton_ID' => '52 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $tote2 = (object) ['objectID' => '200'.__LINE__.'003', 'Carton_ID' => '53 0024 0'.__LINE__, 'Status' => 'OPEN'];
        $inventory0 = (object) ['objectID' => '300'.__LINE__.'000', 'Item' => '400'.__LINE__.'000', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $inventory1 = (object) ['objectID' => '300'.__LINE__.'001', 'Item' => '400'.__LINE__.'001', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];
        $inventory2 = (object) ['objectID' => '300'.__LINE__.'002', 'Item' => '400'.__LINE__.'002', 'Quantity' => 1, 'Status' => 'OPEN', 'Order_Line' => '62050'.__LINE__];

        // Create a map of arguments to return values.
        $tote_filterOn_returnMap = array(
            array(['container.child' => $inventory0->objectID], 2, [$tote0]),
            array(['container.child' => $inventory1->objectID], 2, [$tote1]),
            array(['container.child' => $inventory2->objectID], 2, [$tote2]),
        );
        $pallet_filterOn_returnMap = array(
            array(['container.child' => $tote->objectID], 2, [$pallet]),
            array(['container.child' => $tote0->objectID], 2, [$pallet0]),
            array(['container.child' => $tote1->objectID], 2, [$pallet1]),
            array(['container.child' => $tote2->objectID], 2, [$pallet2]),
        );
        $location_filterOn_returnMap = array(
            array(['container.child' => $pallet->objectID], 2, [$location]),
            array(['container.child' => $pallet0->objectID], 2, [$location0]),
            array(['container.child' => $pallet1->objectID], 2, [$location1]),
            array(['container.child' => $pallet2->objectID], 2, [$location2]),
        );

        // prepare mock objects
        self::$toteRepository
            ->method('filterOn')
            ->will($this->returnValueMap($tote_filterOn_returnMap));
        self::$toteRepository
            ->method('isEmpty')
            ->willReturn(false);

        // prepare mock objects
        self::$palletRepository
            ->method('filterOn')
            ->will($this->returnValueMap($pallet_filterOn_returnMap));

        // prepare mock objects
        self::$locationRepository
            ->method('filterOn')
            ->will($this->returnValueMap($location_filterOn_returnMap));

        LogMock::reset();
        LogMock::info('inventory0 - inventory in a Pick Face into Pick Face');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory0, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertTrue($result, 'inventory0, 3. move pick into pick face location');

        LogMock::reset();
        LogMock::info('inventory1 - inventory in an Activity into Pick Face -> negative test');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory1, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveLocType'], LangMock::$key);
        $this->assertEquals(1, LangMock::$count);

        LogMock::reset();
        LogMock::info('inventory2 - inventory in Reserve into Pick Face -> negative test');

        // invoke method
        $result = $this->comingleRules->inventoryMovementAtTheLocTypeLevelRules($inventory2, $tote);

        // assert on results
        LogMock::dumpMessages();
        $this->assertEquals(LangMock::$expectedKeys['notMoveLocType'], LangMock::$key);
        $this->assertEquals(2, LangMock::$count);
    }

}
